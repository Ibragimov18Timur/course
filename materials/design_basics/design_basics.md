{% include header.md %}

Основы проектирования и дизайна
===
{% include module-not-completed-basic.md %}

Структура типичных Java-приложений
---------------------
Возможно вы заметили, что приложения прошлых практик имеют схожую структуру. В этом разделе мы попытаемся объяснить, 
почему и для чего это сделано, попутно проанализировав их составные части.

**Любое** приложение работает с какими-либо данными: одни обрабатывают платежи, другие показывают доступные товары в 
интернет-магазине, а третьи выполняют поисковые запросы, составленные пользователем. Во всех этих случаях у нас есть 
**бизнес-домен** - банк, интернет-магазин или поисковая система.

> Бизнес-домен - набор объектов и отношений между ними, которые характеризуют какую-либо предметную область из реального 
мира.  
> Пример: Банковская система.(упрощенно)  
> Сущности: Пользователь, организация, счет, платеж, депозит, карта,
> Связи: Пользователь принадлежит организации. У пользователя может быть много счетов. Организация делает платеж другой 
организации. Пользователь открывает депозит. Пользователь заводит карту.

Сущности в контексте приложения обычно называются **Entity**

> Entity - сущность из бизнес-домена, представленная в нашей программе как класс, в котором есть только поля, геттеры и 
сеттеры. Никакая логика не должна содержаться в этом классе.

Иногда выделяют также и **DTO**(Data-transfer object). Технически, это то же самое, что и Entity, но с точки зрения бизнес-
домена, эти объекты никак не связаны с ней. Например: несколько полей, объединенных в сущность для отправки в сервис 
получения документов, удостоверяющих личность пользователя.

Какие же сущности отвечают за выполнение логики с сущностями в нашем приложении? Такие классы именуются **Сервисами**, и
 **Репозиториями**. Очень важно понимать разницу между ними и поектировать свое приложение, правильно разбивая его функционал.

> Service - класс, который отвечает за бизнес-логику с конкретным Entity или DTO. 

> Repository - класс, который взаимодействует с каким-либо физическим хранилищем(например База данных) наших объектов.

В чем же разница? Приведем пример из реальной жизни: мы пришли в банк и хотим положить 10 рублей на наш счет. Мы подходим к
кассе и говорим операционисту наш счет, ФИО и деньги. Она пересчитывает деньги, сверяет данные и кладет деньги в кассу.
С точки зрения бизнесс-домена, оператор это сервис, а касса, с которой она взаимодействует это репозиторий. Заметим следующие
особенности:
+ Сервис выполняет валидацию данных и, если воникла ошибка, говорит её.
+ Сервис обращается к репозиторию, у которого есть свой интерфейс и внутренняя логика, скрытая от сервиса.
+ Если мы захотим поменять репозиторий (способ работы с деньгами), то логика работы сервиса для конечного пользователя (нас)
останется неизменной, что придает гибкости нашей программе.
+ Сервис может выполнять какие-то дополнительные функции, которые нужны для нашего бизнес-процесса. Например, при успешном
зачислении денег операционист выдает чек-квитанцию.

Важно понимать, что при переносе такой модели в программный код, все реалзации классов должны лежать в своих пакетах, которые
соответствуют их сущности: `entity`, `dto`, `service`, `repostory`. Например:  
![Так](./img/project_structure.png)

Иногда слой хранения данных делят на 2 паттерна:
+ DAO (Data Access Object)
+ рассмотренный выше Repository

Они оба отвечают за взаимодействие с каким-то хранилищем сущностей. В чем же тогда заключается разница между ними?

Представим ситуацию, что мы реализуем хранение сущности `User`. В случае с `UserRepository` у нас был бы следующий интерфейс:
```java
interface UserRepository {
    
    User get(String userName);
    void create(User user);
    void update(User user);
    void delete(String userName);
 
    List<User> getUserByLastName(String lastName);
    User getUserByAgeRange(int minAge, int maxAge);
    // Еще миллион методов поиска с размыни параметрами
    
}
```

А в случае с `UserDAO` такой: 
```java
interface UserDAO {
    
    void create(User user);
    void update(User user);
    void delete(User user);
    
    List<User> query(UserSpecification specification); // Один метод что правит всеми запросами поиска
    
}
```

Наверное, вы уже уловили суть. Самое главное отличие Repository от DAO в том, что DAO инкапсулируют всевозможные варианты 
поиска сущности в какой-то объект UserSpecification. В нем могут содержаться различные комбинации полей, по которым идет
поиск, сколько страниц сущностей мы хотим увидеть и в каком порядке (сортировка)

В общем случае наша программа будет выглядеть следующим образом (Разве что у нас нет базы данных):  
![Так](./img/project_layers.png)

Чистый код
---------------------
Для того чтобы хорошо написать программу, недостаточно просто знать, на какие классы разделить функционал. Важно знать и
понимать, как писать качественный, красивый и легкий в поддержке код.

### Принцип S.O.L.I.D.
Принцип S.O.L.I.D. - это акроним из 5 основных принципов проектирования программ:
1. Single Responsibility (Принцип единственной ответственности ) - Каждый класс должен иметь одну и только одну причину 
для изменений. С нарушением SRP система с трудом поддается изменениям, поскольку любое минимальное изменение вызывает 
эффект «снежного кома», затрагивающего другие компоненты системы.
1. Open Closed Principle (Принцип открытости/закрытости) - Программные сущности должны быть:
* открыты для расширения(наследования)
* закрыты для изменения  
Идея в том, что однажды разработанная реализация класса в дальнейшем требует только исправления ошибок, а новые или 
изменённые функции требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса через 
механизм наследования. Производный подкласс может реализовывать или не реализовывать интерфейс исходного класса.
1. Liskov Substitution Principle (Принцип подстановки Барбары Лисков) - объекты в программе должны быть заменяемыми на 
экземпляры их подтипов без изменения правильности выполнения программы. Проще говоря, если у вас в проекте повсеместно 
используется экземпляры класса `Collection`, то вы вольны заменить их на `List`, `Set` или `Queue`.
1. 
1. 

### Принцип DRY

### Принцип YAGNI

### Принцип KISS

Основные материалы
---------------------
1. [Видео: Learn - Clean Code](https://learn.by/courses/course-v1:EPAM+CC+ext1/about){:target="_blank"}

Дополнительные материалы
---------------------
1. [Три ключевых принципа ПО, которые вы должны понимать](https://habr.com/ru/post/144611/){:target="_blank"}
1. [Stackoverflow: DTO vs entity](https://stackoverflow.com/questions/39397147/difference-between-entity-and-dto){:target="_blank"}
1. [Stackoverflow: Repository vs service](https://stackoverflow.com/questions/1440096/difference-between-repository-and-service){:target="_blank"}
1. [Habr: DAO vs Repository](https://habr.com/ru/post/263033/){:target="_blank"}
1. [Стиль кода Java](https://github.com/lanit-tercom-school/grouplock/wiki/%D0%9A%D0%BE%D0%B4-%D1%81%D1%82%D0%B0%D0%B9%D0%BB-%D0%B4%D0%BB%D1%8F-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-Java/){:target="_blank"}
1. [Книга: Чистый код](./books/Чистый%20Код%20(Роберт%20Мартин).djvu)

https://habr.com/ru/post/155959/
https://habr.com/ru/company/payonline/blog/277629/
https://habr.com/ru/post/169487/

Вопросы для самоконтроля
---------------------
1. 
